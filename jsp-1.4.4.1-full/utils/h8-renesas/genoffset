#! /usr/bin/perl
#
#  TOPPERS/JSP Kernel
#      Toyohashi Open Platform for Embedded Real-Time Systems/
#      Just Standard Profile Kernel
# 
#  Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
#                              Toyohashi Univ. of Technology, JAPAN
#  Copyright (C) 2004 by Embedded and Real-Time Systems Laboratory
#              Graduate School of Information Science, Nagoya Univ., JAPAN
#  Copyright (C) 2005-2007 by Industrial Technology Institute,
#                              Miyagi Prefectural Government, JAPAN
# 
#  上記著作権者は，以下の (1)～(4) の条件か，Free Software Foundation 
#  によって公表されている GNU General Public License の Version 2 に記
#  述されている条件を満たす場合に限り，本ソフトウェア（本ソフトウェア
#  を改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
#  利用と呼ぶ）することを無償で許諾する．
#  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
#      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
#      スコード中に含まれていること．
#  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
#      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
#      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
#      の無保証規定を掲載すること．
#  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
#      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
#      と．
#    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
#        作権表示，この利用条件および下記の無保証規定を掲載すること．
#    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
#        報告すること．
#  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
#      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
# 
#  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
#  よびTOPPERSプロジェクトは，本ソフトウェアに関して，その適用可能性も
#  含めて，いかなる保証も行わない．また，本ソフトウェアの利用により直
#  接的または間接的に生じたいかなる損害に関しても，その責任を負わない．
# 
#  @(#) $Id: genoffset,v 1.8 2007/03/23 07:25:47 honda Exp $
# 

#
#  makeoffset.cのアセンブル結果から構造体内のオフセットを求める
#　　ルネサス製コンパイラ H8C専用
#
#　　使い方
#　　　perl genoffset makeoffset.src
#


#
#  初期化
#
$infile = $ARGV[0];

#
#  ビットサーチ
#
sub search_bit {
	my($val) = @_;
	my($val_bit);

	return(-1) if ($val == 0);

	$val_bit = 0;
	while (($val & 1) == 0) {
		$val >>= 1;
		$val_bit++;
	}
	return($val_bit);
}

#
#  オフセット値の出力
#
#　　対象パターンの例：
#　　　　MOV.L       #22,ER0
#　　　　MOV.L       #H'00000010,ER0
#　　　　MOV.W       #4,R0
#　　　　MOV.W       #H'0010,R0
#　　　　MOV.B       #8,R0L
#　　　　MOV.B       #8:8,R0L
#　　　　MOV.B       #H'1A:8,R0L
#
sub parse_offset {
	my($label) = @_;
	my($offset);

	while ($line = <INFILE>) {
		chomp $line;
							# 10進数4バイトの場合
		if ($line =~ /MOV\.L +#([\d]+)(:32)* *, *ER0/) {
			$offset = $1;
			
			# 定義の出力
			printf "%s:\t.DEFINE\t\"%s\"\n", $label, $offset;
			last;
		}
							# 10進数2バイトの場合
		elsif ($line =~ /MOV\.W +#([\d]+)(:16)* *, *R0/) {
			$offset = $1;
			
			# 定義の出力
			printf "%s:\t.DEFINE\t\"%s\"\n", $label, $offset;
			last;
		}
							# 10進数1バイトの場合
		elsif ($line =~ /MOV\.B +#([\d]+)(:8)* *, *R0L/) {
			$offset = $1;
			
			# 定義の出力
			printf "%s:\t.DEFINE\t\"%s\"\n", $label, $offset;
			last;
		}
							# 16進数4バイトの場合
		elsif ($line =~ /MOV\.L +#H\'([0-9a-fA-F]+)(:32)* *, *ER0/) {
			$offset = $1;
			
			# 定義の出力
			printf "%s:\t.DEFINE\t\"H\'%s\"\n", $label, $offset;
			last;
		}
							# 16進数2バイトの場合
		elsif ($line =~ /MOV\.W +#H\'([0-9a-fA-F]+)(:16)* *, *R0/) {
			$offset = $1;
			
			# 定義の出力
			printf "%s:\t.DEFINE\t\"H\'%s\"\n", $label, $offset;
			last;
		}
							# 16進数1バイトの場合
		elsif ($line =~ /MOV\.B +#H\'([0-9a-fA-F]+)(:8)* *, *R0L/) {
			$offset = $1;
			
			# 定義の出力
			printf "%s:\t.DEFINE\t\"H\'%s\"\n", $label, $offset;
			last;
		}

		elsif ($line =~ /^ *RTS$/) {	# rts命令の場合
			print "#error Parse error: $label by genoffset script\n";
			close(INFILE);
			print STDERR "Error: parse error $label by genoffset script\n";
			exit(1);
		}
	}
}

#
#  ビットフィールドの解析
#
sub parse_bit {
	my($label) = @_;
	my($data, $zero, $ptn, $len, $offset, $bit);
	$data = "";

	while ($line = <INFILE>) {
		chomp $line;
		if ($line =~ s/\.DATA\.[LW]//) {
			$line =~ s/[^0-9a-fA-F]//g;
			$data .= $line;
		} else {
			last;
		}
	}
	
	$data =~ /(0+)([^0])/;
	$zero = $1;
	$ptn = $2;
	
	$len = length($zero);
	$offset = int($len / 2);
	$bit = search_bit($ptn);
	if (($len % 2) eq 0) {
		$bit += 4;
	}

	# 定義の出力
	printf "%s:\t.DEFINE\t\"%s\"\n", $label, $offset;
	printf "%s_bit:\t.DEFINE\t\"%s\"\n", $label, $bit;
	printf "%s_mask:\t.DEFINE\t\"H\'%x\"\n", $label, (1 << $bit);
}


#
#  メインルーチン
#
print "; This file is generated by genoffset.\n";
print "\n";

$error = 0;
open(INFILE, $infile) || die "Cannot open $infile";

while ($line = <INFILE>) {
	chomp $line;
	
	if ($line =~ /^_OFFSET_DEF_([^ \t]+):/) {
		do parse_offset($1);
	}
	elsif ($line =~ /^_BIT_FIELD_OFFSET_([^ \t]+):/) {
		do parse_bit($1);
	}
}

close(INFILE);
exit($error);
